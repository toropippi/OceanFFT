#pragma kernel FFT2Dfunc256inv
#define PI 3.14159265358979323846264338328
RWStructuredBuffer<float2> buffer;//xが実数、yが虚数を格納
RWStructuredBuffer<float2> buffer_dmy;//xが実数、yが虚数を格納


//256*256要素の2D IFFT専用
groupshared float2 block[256];
[numthreads(128, 1, 1)]
void FFT2Dfunc256inv(uint id : SV_DispatchThreadID, uint grid : SV_GroupID, uint gi : SV_GroupIndex)
{
	const int lgn = 8;
	const int n = 1 << lgn;
	block[gi * 2] = buffer[grid * n + gi * 2];
	block[gi * 2 + 1] = buffer[grid * n + gi * 2 + 1];

	for (int loopidx = 0; loopidx < lgn; loopidx++)
	{
		int blocksz = 1 << (lgn - loopidx - 1);
		uint t2 = gi % blocksz;
		uint t0 = (gi / blocksz) * blocksz * 2 + t2;
		uint t1 = t0 + blocksz;
		GroupMemoryBarrierWithGroupSync();
		float rx = block[t1].x;
		float ix = block[t1].y;
		float rm0 = block[t0].x - rx;
		float im0 = block[t0].y - ix;
		float rot = 3.14159265358979323846264338328 * t2 / blocksz;//invなので-がかかっている
		float dsin = sin(rot);
		float dcos = cos(rot);
		block[t0].x += rx;
		block[t0].y += ix;
		block[t1].x = rm0 * dcos - im0 * dsin;
		block[t1].y = rm0 * dsin + im0 * dcos;
	}

	GroupMemoryBarrierWithGroupSync();
	float2 tmp0 = block[reversebits(gi * 2) >> (32 - lgn)];
	float2 tmp1 = block[reversebits(gi * 2 + 1) >> (32 - lgn)];
	buffer_dmy[gi * 2 * n + grid] = tmp0;//書き込みはx,yを転置している。これによって2D FFTの計算の1回目と2回目を
	buffer_dmy[(gi * 2 + 1) * n + grid] = tmp1;//同じコードにできて、かつ、最終的なメモリ配置は最初と同じに戻る
}